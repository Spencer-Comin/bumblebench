/*******************************************************************************
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#define NAME__(tm) Put ## tm ## Bench
#define NAME_(tm) NAME__(tm)
#define NAME NAME_(TYPEMODE)

#define OP__(tm) put ## tm
#define OP_(tm) OP__(tm)
#define OP OP_(TYPEMODE)

package net.adoptopenjdk.bumblebench.unsafe;

import net.adoptopenjdk.bumblebench.core.MicroBench;
import jdk.internal.misc.Unsafe;
import java.lang.reflect.Field;
import java.lang.reflect.InaccessibleObjectException;

public class NAME {
    static final Unsafe UNSAFE;
    static final TYPE val = INIT;

    static {
        try {
            Field f = Unsafe.class.getDeclaredField("theUnsafe");
            f.setAccessible(true);
            UNSAFE = (Unsafe) f.get(null);
        } catch (IllegalAccessError e) {
            System.err.println("add \"--add-exports java.base/jdk.internal.misc=ALL-UNNAMED\" to your java command");
            throw new RuntimeException("Unable to get Unsafe instance.", e);
        } catch (InaccessibleObjectException e) {
            System.err.println("add \"--add-opens java.base/jdk.internal.misc=ALL-UNNAMED\" to your java command");
            throw new RuntimeException("Unable to get Unsafe instance.", e);
        } catch (Exception e) {
            throw new RuntimeException("Unable to get Unsafe instance.", e);
        }
    }

    public static class NativeAddress extends MicroBench {
        static final long offset1;
        static final long offset2;

        static {
            offset1 = Native.getOffset1();
            offset2 = Native.getOffset2();
        }

        protected long doBatch(long numIterations) {
            boolean toggle = false;

            // cache everything before the loop so there aren't any extra loads in the loop
            long o1 = offset1;
            long o2 = offset2;
            Unsafe u = UNSAFE;
            TYPE v = val;

            long i;
            Object b;
            long o;
            for (i = 0; i < numIterations; i++) {
                if (toggle) {
                    o = o1;
                } else {
                    o = o2;
                }
                toggle = !toggle;

                u.OP(null, o, v);
            }

            return i;
        }
    }

    public static class Member extends MicroBench {
        TYPE field1;
        TYPE field2;

        static final Object base = new Member();
        static final long field1Offset;
        static final long field2Offset;

        static {
            try {
                Field f = Member.class.getDeclaredField("field1");
                field1Offset = UNSAFE.objectFieldOffset(f);

                f = Member.class.getDeclaredField("field2");
                field2Offset = UNSAFE.objectFieldOffset(f);
            } catch (NoSuchFieldException e) {
                // should never happen
                throw new RuntimeException(e);
            }
        }

        protected long doBatch(long numIterations) {
            boolean toggle = false;

            // cache everything before the loop so there aren't any extra loads in the loop
            Object b = base;
            long o1 = field1Offset;
            long o2 = field2Offset;
            Unsafe u = UNSAFE;
            TYPE v = val;

            long i;
            long o;
            for (i = 0; i < numIterations; i++) {
                if (toggle) {
                    o = o1;
                } else {
                    o = o2;
                }
                toggle = !toggle;

                u.OP(b, o, v);
            }

            return i;
        }
    }

    public static class StaticField extends MicroBench {
        static TYPE field1;
        static TYPE field2;

        static final Object field1Base;
        static final Object field2Base;
        static final long field1Offset;
        static final long field2Offset;

        static {
            try {
                Field f = StaticField.class.getDeclaredField("field1");
                field1Base = UNSAFE.staticFieldBase(f);
                field1Offset = UNSAFE.staticFieldOffset(f);

                f = StaticField.class.getDeclaredField("field2");
                field2Base = UNSAFE.staticFieldBase(f);
                field2Offset = UNSAFE.staticFieldOffset(f);
            } catch (NoSuchFieldException e) {
                // should never happen
                throw new RuntimeException(e);
            }
        }

        protected long doBatch(long numIterations) {
            boolean toggle = false;

            // cache everything before the loop so there aren't any extra loads in the loop
            Object b1 = field1Base;
            Object b2 = field2Base;
            long o1 = field1Offset;
            long o2 = field2Offset;
            Unsafe u = UNSAFE;
            TYPE v = val;

            long i;
            long o;
            Object b;
            for (i = 0; i < numIterations; i++) {
                if (toggle) {
                    b = b1;
                    o = o1;
                } else {
                    b = b2;
                    o = o2;
                }
                toggle = !toggle;

                u.OP(b, o, v);
            }

            return i;
        }
    }

    public static class Array extends MicroBench {
        static final int shift;
        static final int offset;

        private static final int arraySize = 0x8000000;
        private static final Object array;

        static {
            offset = UNSAFE.arrayBaseOffset(TYPE[].class);
            int ascale = UNSAFE.arrayIndexScale(TYPE[].class);
            shift = 31 - Integer.numberOfLeadingZeros(ascale);

            array = new TYPE[arraySize];
        }

        protected long doBatch(long numIterations) {
            int size = (int) Math.min(numIterations, arraySize);

            // cache everything before the loop so there aren't any loads in the loop
            Object b = array;
            int o = offset;
            int s = shift;
            Unsafe u = UNSAFE;
            TYPE v = val;

            long i;
            for (i = 0; i < size; i++)
                u.OP(b, (i << s) + o, v);

            return i;
        }
    }
}
